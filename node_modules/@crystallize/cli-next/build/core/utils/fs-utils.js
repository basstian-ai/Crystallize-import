import fs from 'fs';
export async function isDirectoryEmpty(path) {
    return fs.promises.readdir(path).then((files) => {
        return files.length === 0;
    });
}
export function makeDirectory(path) {
    if (!fs.existsSync(path)) {
        fs.mkdirSync(path, { recursive: true });
        return true;
    }
    return false;
}
export function isFileExists(path) {
    return fs.existsSync(path);
}
export function loadFile(path) {
    return new Promise((resolve, reject) => {
        fs.readFile(path, 'utf8', (err, content) => {
            if (err) {
                reject(err);
            }
            else {
                try {
                    resolve(content);
                }
                catch (err) {
                    reject(err);
                }
            }
        });
    });
}
export async function loadJSON(path) {
    const text = await loadFile(path);
    return JSON.parse(text);
}
export function loadMarkdown(path) {
    return new Promise((resolve, reject) => {
        fs.readFile(path, 'utf8', (err, content) => {
            if (err) {
                reject(err);
            }
            else {
                try {
                    resolve(JSON.parse(content));
                }
                catch (err) {
                    reject(err);
                }
            }
        });
    });
}
export async function removeFile(path) {
    return new Promise((resolve, reject) => {
        fs.unlink(path, (err) => {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
export async function saveFile(path, content) {
    return new Promise((resolve, reject) => {
        fs.writeFile(path, content, function (err) {
            if (err) {
                reject(err);
            }
            else {
                resolve();
            }
        });
    });
}
export async function replaceInFile(path, keyValues) {
    return new Promise((resolve, reject) => {
        fs.readFile(path, 'utf8', (err, content) => {
            if (err) {
                reject(err);
            }
            else {
                const newContent = keyValues.reduce((memo, keyValue) => {
                    return memo.replace(keyValue.search, keyValue.replace);
                }, content);
                saveFile(path, newContent).then(resolve).catch(reject);
            }
        });
    });
}
