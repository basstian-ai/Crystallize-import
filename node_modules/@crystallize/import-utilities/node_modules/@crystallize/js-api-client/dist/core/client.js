"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createClient = createClient;
const node_fetch_1 = __importDefault(require("node-fetch"));
function authenticationHeaders(config) {
    if (config.sessionId) {
        return {
            Cookie: 'connect.sid=' + config.sessionId,
        };
    }
    if (config.staticAuthToken) {
        return {
            'X-Crystallize-Static-Auth-Token': config.staticAuthToken,
        };
    }
    return {
        'X-Crystallize-Access-Token-Id': config.accessTokenId || '',
        'X-Crystallize-Access-Token-Secret': config.accessTokenSecret || '',
    };
}
async function post(path, config, query, variables, init, profiling) {
    try {
        const { headers: initHeaders, ...initRest } = init || {};
        const headers = {
            'Content-type': 'application/json; charset=UTF-8',
            Accept: 'application/json',
            ...authenticationHeaders(config),
            ...initHeaders,
        };
        const body = JSON.stringify({ query, variables });
        let start = 0;
        if (profiling) {
            start = Date.now();
            if (profiling.onRequest) {
                profiling.onRequest(query, variables);
            }
        }
        const response = await (0, node_fetch_1.default)(path, {
            ...initRest,
            method: 'POST',
            headers,
            body,
        });
        if (profiling) {
            const ms = Date.now() - start;
            const serverTiming = response.headers.get('server-timing') ?? undefined;
            const duration = serverTiming?.split(';')[1]?.split('=')[1] ?? -1;
            profiling.onRequestResolved({
                resolutionTimeMs: ms,
                serverTimeMs: Number(duration),
            }, query, variables);
        }
        if (response.ok && 204 === response.status) {
            return {};
        }
        if (!response.ok) {
            const json = await response.json();
            throw {
                code: response.status,
                statusText: response.statusText,
                message: json.message,
                errors: json.errors || {},
            };
        }
        // we still need to check for error as the API can return 200 with errors
        const json = await response.json();
        if (json.errors) {
            throw {
                code: 400,
                statusText: 'Error was returned from the API',
                message: json.errors[0].message,
                errors: json.errors || {},
            };
        }
        return json.data;
    }
    catch (exception) {
        throw exception;
    }
}
function apiHost(configuration) {
    const origin = configuration.origin || '.crystallize.com';
    return (path, prefix = 'api') => `https://${prefix}${origin}/${path.join('/')}`;
}
function createApiCaller(uri, configuration, options) {
    return function callApi(query, variables) {
        return post(uri, configuration, query, variables, undefined, options?.profiling);
    };
}
const getExpirationAtFromToken = (token) => {
    const payload = token.split('.')[1];
    const decodedPayload = Buffer.from(payload, 'base64').toString('utf-8');
    const parsedPayload = JSON.parse(decodedPayload);
    return parsedPayload.exp * 1000;
};
function shopApiCaller(configuration, options) {
    const identifier = configuration.tenantIdentifier;
    let shopApiToken = configuration.shopApiToken;
    return async function callApi(query, variables) {
        const tokenExpiresAt = shopApiToken ? getExpirationAtFromToken(shopApiToken) : null;
        const isTokenAboutToExpireOrIsExpired = tokenExpiresAt ? tokenExpiresAt - Date.now() < 1000 * 60 * 5 : true;
        if ((!shopApiToken || isTokenAboutToExpireOrIsExpired) && options?.shopApiToken?.doNotFetch !== true) {
            //static auth token must be removed to fetch the shop api token
            const { staticAuthToken, ...withoutStaticAuthToken } = configuration;
            const headers = {
                'Content-type': 'application/json; charset=UTF-8',
                Accept: 'application/json',
                ...authenticationHeaders(withoutStaticAuthToken),
            };
            const response = await (0, node_fetch_1.default)(apiHost(configuration)([`@${identifier}`, 'auth', 'token'], 'shop-api'), {
                method: 'POST',
                headers,
                body: JSON.stringify({
                    scopes: options?.shopApiToken?.scopes || ['cart'],
                    expiresIn: options?.shopApiToken?.expiresIn || 3600 * 12,
                }),
            });
            const results = await response.json();
            if (results.success !== true) {
                throw new Error('Could not fetch shop api token: ' + results.error);
            }
            shopApiToken = results.token;
        }
        return post(apiHost(configuration)([`@${identifier}`, 'cart'], 'shop-api'), {
            ...configuration,
            shopApiToken: shopApiToken,
        }, query, variables, {
            headers: {
                Authorization: `Bearer ${shopApiToken}`,
            },
        }, options?.profiling);
    };
}
function createClient(configuration, options) {
    const identifier = configuration.tenantIdentifier;
    // let's rewrite the configuration based on the need of the endpoint
    // authenticationHeaders manages this priority: sessionId > staticAuthToken > accessTokenId/accessTokenSecret
    const commonConfig = {
        tenantIdentifier: configuration.tenantIdentifier,
        tenantId: configuration.tenantId,
        origin: configuration.origin,
    };
    // static auth token is excluded
    const pimConfig = {
        ...commonConfig,
        sessionId: configuration.sessionId,
        accessTokenId: configuration.accessTokenId,
        accessTokenSecret: configuration.accessTokenSecret,
    };
    // sessionId is excluded
    const catalogConfig = {
        ...commonConfig,
        staticAuthToken: configuration.staticAuthToken,
        accessTokenId: configuration.accessTokenId,
        accessTokenSecret: configuration.accessTokenSecret,
    };
    // sessionId and static auth token are excluded
    const tokenOnlyConfig = {
        ...commonConfig,
        accessTokenId: configuration.accessTokenId,
        accessTokenSecret: configuration.accessTokenSecret,
    };
    return {
        catalogueApi: createApiCaller(apiHost(configuration)([identifier, 'catalogue']), catalogConfig, options),
        searchApi: createApiCaller(apiHost(configuration)([identifier, 'search']), catalogConfig, options),
        orderApi: createApiCaller(apiHost(configuration)([identifier, 'orders']), tokenOnlyConfig, options),
        subscriptionApi: createApiCaller(apiHost(configuration)([identifier, 'subscriptions']), tokenOnlyConfig, options),
        pimApi: createApiCaller(apiHost(configuration)(['graphql'], 'pim'), pimConfig, options),
        nextPimApi: createApiCaller(apiHost(configuration)([`@${identifier}`]), pimConfig, options),
        shopCartApi: shopApiCaller(configuration, options),
        config: {
            tenantId: configuration.tenantId,
            tenantIdentifier: configuration.tenantIdentifier,
            origin: configuration.origin,
        },
    };
}
//# sourceMappingURL=client.js.map