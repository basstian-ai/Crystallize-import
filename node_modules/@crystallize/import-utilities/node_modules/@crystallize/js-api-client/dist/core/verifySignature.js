"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createSignatureVerifier = exports.createAsyncSignatureVerifier = void 0;
const newQueryParams = (webhookUrl, receivedUrl) => {
    const parseQueryString = (url) => {
        const urlParams = new URL(url).searchParams;
        let params = {};
        for (const [key, value] of urlParams.entries()) {
            params[key] = value;
        }
        return params;
    };
    const webhookOriginalParams = parseQueryString(webhookUrl);
    const receivedParams = parseQueryString(receivedUrl);
    const result = {};
    for (const [key, value] of Object.entries(receivedParams)) {
        if (!webhookOriginalParams.hasOwnProperty(key)) {
            result[key] = value;
        }
    }
    return result;
};
const buildChallenge = (request) => {
    return {
        url: request.url,
        method: request.method,
        body: request.body ? JSON.parse(request.body) : null,
    };
};
const buildGETSituationChallenge = (request) => {
    if (request.url && request.webhookUrl && request.method && request.method.toLowerCase() === 'get') {
        const body = newQueryParams(request.webhookUrl, request.url);
        if (Object.keys(body).length > 0) {
            return {
                url: request.webhookUrl,
                method: request.method,
                body,
            };
        }
    }
    return null;
};
const createAsyncSignatureVerifier = ({ sha256, jwtVerify, secret }) => {
    return async (signature, request) => {
        try {
            const payload = await jwtVerify(signature, secret);
            const isValid = async (challenge) => payload.hmac === (await sha256(JSON.stringify(challenge)));
            const challenge = buildChallenge(request);
            if (!(await isValid(challenge))) {
                const newChallenge = buildGETSituationChallenge(request);
                if (newChallenge && (await isValid(newChallenge))) {
                    return payload;
                }
                throw new Error('Invalid signature. HMAC does not match.');
            }
            return payload;
        }
        catch (exception) {
            throw new Error('Invalid signature. ' + exception.message);
        }
    };
};
exports.createAsyncSignatureVerifier = createAsyncSignatureVerifier;
/**
 * @deprecated you should use the `createAsyncSignatureVerifier` function instead
 */
const createSignatureVerifier = ({ sha256, jwtVerify, secret }) => {
    return (signature, request) => {
        try {
            const payload = jwtVerify(signature, secret);
            const isValid = (challenge) => payload.hmac === sha256(JSON.stringify(challenge));
            const challenge = buildChallenge(request);
            if (!isValid(challenge)) {
                const newChallenge = buildGETSituationChallenge(request);
                if (newChallenge && isValid(newChallenge)) {
                    return payload;
                }
                throw new Error('Invalid signature. HMAC does not match.');
            }
            return payload;
        }
        catch (exception) {
            throw new Error('Invalid signature. ' + exception.message);
        }
    };
};
exports.createSignatureVerifier = createSignatureVerifier;
//# sourceMappingURL=verifySignature.js.map