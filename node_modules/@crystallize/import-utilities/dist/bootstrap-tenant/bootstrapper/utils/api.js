"use strict";
var __classPrivateFieldGet = (this && this.__classPrivateFieldGet) || function (receiver, state, kind, f) {
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a getter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot read private member from an object whose class did not declare it");
    return kind === "m" ? f : kind === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var __classPrivateFieldSet = (this && this.__classPrivateFieldSet) || function (receiver, state, value, kind, f) {
    if (kind === "m") throw new TypeError("Private method is not writable");
    if (kind === "a" && !f) throw new TypeError("Private accessor was defined without a setter");
    if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError("Cannot write private member to an object whose class did not declare it");
    return (kind === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;
};
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
var _ApiManager_MAX_WORKERS;
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAPICaller = exports.ApiManager = exports.sleep = void 0;
const graphql_request_1 = require("graphql-request");
const uuid_1 = require("uuid");
const killable_worker_1 = require("./killable-worker");
function sleep(ms) {
    return new Promise((r) => setTimeout(r, ms));
}
exports.sleep = sleep;
class ApiManager extends killable_worker_1.KillableWorker {
    constructor(url) {
        super();
        this.queue = [];
        this.url = '';
        this.currentWorkers = 1;
        this.logLevel = 'silent';
        this.CRYSTALLIZE_ACCESS_TOKEN_ID = '';
        this.CRYSTALLIZE_ACCESS_TOKEN_SECRET = '';
        this.CRYSTALLIZE_STATIC_AUTH_TOKEN = '';
        this.CRYSTALLIZE_SESSION_ID = '';
        _ApiManager_MAX_WORKERS.set(this, 12);
        this.push = (props) => {
            return new Promise((resolve) => {
                this.queue.push({
                    id: (0, uuid_1.v4)(),
                    resolve,
                    props,
                    failCount: 0,
                });
            });
        };
        this.rateLimitLookbackWindowInMinutes = 5;
        this.rateLimitAvgReqPrSeconds = 15;
        /**
         * Keep a record of the last requests, so that we can adjust
         * the number of requests to the API. Factors that can change
         * the number of current workers are:
         * - Network congestion between this client and the API
         * - Crystallize API rate limiting
         * - Local client errors
         * - Crystallize API errors
         */
        this.lastRequestsStatuses = [];
        this.recordRequestStatus = (status) => {
            var _a;
            const now = new Date();
            this.lastRequestsStatuses.unshift({ date: now, status });
            const errors = (_a = this.lastRequestsStatuses.filter((r) => r.status === 'error')) === null || _a === void 0 ? void 0 : _a.length;
            if (errors > 5) {
                this.currentWorkers--;
            }
            else if (errors === 0) {
                this.currentWorkers++;
            }
            if (this.currentWorkers < 1) {
                this.currentWorkers = 1;
            }
            else if (this.currentWorkers > __classPrivateFieldGet(this, _ApiManager_MAX_WORKERS, "f")) {
                this.currentWorkers = __classPrivateFieldGet(this, _ApiManager_MAX_WORKERS, "f");
            }
            // Keep the request statuses for rate limit lookback window
            const rateLimitLookbackWindowStart = new Date(now.getTime());
            rateLimitLookbackWindowStart.setMinutes(now.getMinutes() - this.rateLimitLookbackWindowInMinutes);
            this.lastRequestsStatuses = this.lastRequestsStatuses.filter((s) => s.date > rateLimitLookbackWindowStart);
        };
        this.url = url;
        this.errorNotifier = () => null;
        this._workIntervalId = setInterval(() => this.work(), 1);
    }
    setErrorNotifier(fn) {
        this.errorNotifier = fn;
    }
    setLogLevel(level) {
        this.logLevel = level;
    }
    backoffOnRateLimit() {
        // Mark all in-flight requests as being part of a rate limited group
        this.queue
            .filter((q) => q.working)
            .forEach((q) => {
            q.partOfRateLimitedGroup = true;
        });
        // Back off, slice current workers in half
        this.currentWorkers = Math.floor(this.currentWorkers / 2);
        if (this.currentWorkers < 1) {
            this.currentWorkers = 1;
        }
    }
    /**
     * Determine if there is a chance for this client alone
     * to go over the rate limit. Since the API rate limiter
     * is IP based, there might be other clients affecting the
     * rate limit, so this measure here is not enough on its own.
     */
    clientOverRateLimit() {
        if (this.lastRequestsStatuses.length === 0) {
            return false;
        }
        const now = new Date();
        // Get the oldest request status (will always be the last one in the array)
        const oldestRequestRecord = this.lastRequestsStatuses[this.lastRequestsStatuses.length - 1];
        const secondsInWindow = (now.getTime() - oldestRequestRecord.date.getTime()) / 1000;
        const reqsInWindow = this.lastRequestsStatuses.length +
            this.queue.filter((i) => i.working).length;
        const avgReqsPrSecond = reqsInWindow / secondsInWindow;
        // Let's stay well beyond the api rate limit
        const localRateLimitReducer = 1;
        const overRateLimit = secondsInWindow > 20 &&
            avgReqsPrSecond >= this.rateLimitAvgReqPrSeconds - localRateLimitReducer;
        return overRateLimit;
    }
    useSingleWorker() {
        __classPrivateFieldSet(this, _ApiManager_MAX_WORKERS, 1, "f");
        this.currentWorkers = 1;
    }
    async work() {
        var _a;
        if (this.isKilled || this.isPaused || this.queue.length === 0) {
            return;
        }
        if (this.clientOverRateLimit()) {
            return;
        }
        const currentWorkers = this.queue.filter((q) => q.working).length;
        if (currentWorkers === this.currentWorkers) {
            return;
        }
        // Get the first none-working item in the queue
        const item = this.queue.find((q) => !q.working);
        if (!item) {
            return;
        }
        item.working = true;
        let queryError = '';
        let otherError = '';
        let serverError = '';
        const resolveWith = (response) => {
            if (item) {
                item.resolve(response);
                // Remove item from queue
                this.queue.splice(this.queue.findIndex((q) => q.id === item.id), 1);
            }
        };
        let response;
        try {
            if (this.logLevel === 'verbose') {
                const _b = item.props, { query } = _b, rest = __rest(_b, ["query"]);
                let printout = item.props;
                if (typeof query !== 'string' && query.loc && query.loc.source.body) {
                    printout = Object.assign({ query: query.loc.source.body }, rest);
                }
                console.log(JSON.stringify(printout, null, 1));
            }
            response = await (0, graphql_request_1.request)(this.url, item.props.query, item.props.variables, this.CRYSTALLIZE_SESSION_ID
                ? {
                    Cookie: `connect.sid=${this.CRYSTALLIZE_SESSION_ID}`,
                }
                : {
                    'X-Crystallize-Access-Token-Id': this.CRYSTALLIZE_ACCESS_TOKEN_ID,
                    'X-Crystallize-Access-Token-Secret': this.CRYSTALLIZE_ACCESS_TOKEN_SECRET,
                    'X-Crystallize-Static-Auth-Token': this.CRYSTALLIZE_STATIC_AUTH_TOKEN,
                });
            if (this.logLevel === 'verbose') {
                console.log(JSON.stringify(response, null, 1));
            }
        }
        catch (e) {
            if (this.logLevel === 'verbose') {
                console.log(e);
            }
            // Rate limited
            if (((_a = e.response) === null || _a === void 0 ? void 0 : _a.status) === 429) {
                /**
                 * Invoke the backoff mechanism, unless the request is already
                 * part of a rate limted group, in which case the backoff has
                 * already been set in motion.
                 */
                if (!item.partOfRateLimitedGroup) {
                    this.backoffOnRateLimit();
                    if (!item.props.suppressErrors) {
                        this.errorNotifier({
                            willRetry: true,
                            error: `Oh dear, you've been temporarily rate limited. Resuming operations in a short while.`,
                        });
                    }
                    // Pause for 30 seconds, then clear the partOfRateLimitedGroup flag
                    this.pauseFor(30000, () => {
                        this.queue.forEach((item) => {
                            item.partOfRateLimitedGroup = false;
                        });
                    });
                }
                this.recordRequestStatus('error');
                item.working = false;
                return;
            }
            // Network/system errors
            if ((e === null || e === void 0 ? void 0 : e.type) === 'system') {
                otherError = e.message || JSON.stringify(e, null, 1);
                if (!item.props.suppressErrors) {
                    this.errorNotifier({
                        willRetry: true,
                        error: otherError,
                    });
                }
            }
            else {
                /**
                 * The API might stumble and throw an internal error "reason: socket hang up".
                 * Deal with this as "serverError" even though the request comes back with a
                 * status 200
                 */
                if (e.message.includes('reason: socket hang up') ||
                    e.message.includes('ECONNRESET') ||
                    e.message.includes('502 Bad Gateway')) {
                    serverError = e.message;
                }
                else {
                    queryError = e.message;
                }
            }
        }
        if (otherError || serverError) {
            /**
             * When server errors or other errors occur, we want to not discard the item
             * that is being worked on, but rather wait until the API is back up
             */
            this.recordRequestStatus('error');
            const err = otherError || serverError;
            item.failCount++;
            await sleep(item.failCount * 1000);
            // Start reporting this as an error after a while
            if (item.failCount > 10 && !item.props.suppressErrors) {
                this.errorNotifier({
                    error: err,
                    willRetry: true,
                });
            }
            item.working = false;
        }
        else {
            this.recordRequestStatus('ok');
            // Report errors in usage of the API
            if (queryError) {
                if (!item.props.suppressErrors) {
                    this.errorNotifier({
                        error: queryError,
                        willRetry: false,
                    });
                }
                resolveWith({ data: null, errors: [{ error: queryError }] });
            }
            else {
                resolveWith({ data: response });
            }
        }
    }
}
exports.ApiManager = ApiManager;
_ApiManager_MAX_WORKERS = new WeakMap();
function createAPICaller({ uri, errorNotifier, logLevel, }) {
    const manager = new ApiManager(uri);
    manager.errorNotifier = errorNotifier;
    if (logLevel) {
        manager.logLevel = logLevel;
    }
    return manager;
}
exports.createAPICaller = createAPICaller;
