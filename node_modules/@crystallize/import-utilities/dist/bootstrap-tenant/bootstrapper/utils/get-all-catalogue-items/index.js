"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getAllCatalogueItems = void 0;
const __1 = require("..");
const multilingual_1 = require("../multilingual");
const parse_raw_item_data_1 = require("./parse-raw-item-data");
const queries_1 = require("./queries");
const utils_1 = require("./utils");
async function getAllCatalogueItems(lng, context, options) {
    const version = (options === null || options === void 0 ? void 0 : options.version) || 'current';
    const languages = context.config.multilingual
        ? context.languages.map((l) => l.code)
        : [lng];
    const pathShouldBeIncluded = (0, utils_1.buildPathShouldBeIncludedValidator)(options === null || options === void 0 ? void 0 : options.basePath);
    if ((options === null || options === void 0 ? void 0 : options.includeDescendantsOfUnpublishedFolders) &&
        options.version !== 'published') {
        context.emit(__1.EVENT_NAMES.WARNING, `includeDescendantsOfUnpublishedFolders is ignored since but item version is not set to published `);
    }
    async function handleLanguage(language) {
        var _a;
        const tr = (0, multilingual_1.trFactory)(language);
        async function getItem({ id, item, }) {
            var _a, _b;
            const response = await context.callPIM({
                query: queries_1.GET_ITEM_QUERY,
                variables: {
                    language,
                    version,
                    id,
                },
            });
            let parsedItem = null;
            const rawCatalogueData = (_b = (_a = response.data) === null || _a === void 0 ? void 0 : _a.item) === null || _b === void 0 ? void 0 : _b.get;
            if (rawCatalogueData) {
                // Fallback when name is not set for draft
                if (rawCatalogueData.name === 'MISSING_NAME_FOR_LANGUAGE') {
                    rawCatalogueData.name = item.name;
                }
                parsedItem = (0, parse_raw_item_data_1.parseRawItemData)({ item: rawCatalogueData, options, tr });
            }
            const children = await getItemChildren({ itemId: id });
            if (children.length > 0) {
                if (parsedItem) {
                    const itemWithChildren = parsedItem;
                    itemWithChildren.children = children;
                }
                else if (
                /**
                 * If there is no item found for this id, we need to check if
                 * descendants still should be fetched, if the following
                 * conditions are met:
                 * - itemVersion: published
                 * - itemConfig.includeDescendantsOfUnpublishedFolders
                 *
                 * In that case, we need to create a dummy folder object that
                 * can hold the children. This item cannot be imported, so we
                 * flag its required fields with unpublishedFolderFieldIndicator
                 */
                (options === null || options === void 0 ? void 0 : options.includeDescendantsOfUnpublishedFolders) &&
                    version === 'published') {
                    const unpublishedFolder = {
                        id,
                        name: tr(utils_1.unpublishedFolderFieldIndicator, `${id}.name`),
                        shape: utils_1.unpublishedFolderFieldIndicator,
                        children,
                    };
                    parsedItem = unpublishedFolder;
                }
            }
            return parsedItem;
        }
        async function getItemChildren({ itemId, }) {
            var _a, _b, _c;
            const children = [];
            const pageResponse = await context.callPIM({
                query: queries_1.GET_ITEM_CHILDREN,
                variables: {
                    language,
                    id: itemId,
                },
            });
            const rawChilds = ((_c = (_b = (_a = pageResponse.data) === null || _a === void 0 ? void 0 : _a.tree) === null || _b === void 0 ? void 0 : _b.getNode) === null || _c === void 0 ? void 0 : _c.children) || [];
            await Promise.all(rawChilds.map(async (rawChild) => {
                const pathValid = pathShouldBeIncluded(rawChild.path);
                if (pathValid.descendants || pathValid.thisItem) {
                    const item = await getItem(rawChild);
                    if (item) {
                        children.push(item);
                    }
                }
            }));
            return children.sort(utils_1.byTreePosition);
        }
        const rootItemId = await (0, __1.getTenantRootItemId)(context);
        const allCatalogueItemsForLanguage = await getItemChildren({
            itemId: rootItemId,
        });
        // Filter out on the desired path in the end
        if ((_a = options === null || options === void 0 ? void 0 : options.basePath) === null || _a === void 0 ? void 0 : _a.length) {
            return (0, utils_1.getOnlyItemsWithPathStartingWith)(options.basePath, allCatalogueItemsForLanguage);
        }
        return allCatalogueItemsForLanguage;
    }
    const allCatalogueItems = [];
    function mergeWithExisting(itemForNewLang, parentId) {
        var _a;
        const existingItem = (0, utils_1.getItemById)(allCatalogueItems, itemForNewLang.id);
        if (!existingItem) {
            // Add it to the parentId children array (if it has it)
            let added = false;
            if (parentId) {
                const parentItem = (0, utils_1.getItemById)(allCatalogueItems, parentId);
                if (parentItem) {
                    const parentItemAsFolder = parentItem;
                    if (!parentItemAsFolder.children) {
                        parentItemAsFolder.children = [];
                    }
                    parentItemAsFolder.children.push(itemForNewLang);
                    added = true;
                }
            }
            if (!added) {
                console.log('Huh, weird. Could not find existing item with id', itemForNewLang.id);
            }
        }
        else {
            // Set shape if not already set
            if (existingItem.shape === utils_1.unpublishedFolderFieldIndicator) {
                existingItem.shape = itemForNewLang.shape;
            }
            // Handle translations
            (0, multilingual_1.mergeInTranslations)(existingItem, itemForNewLang);
        }
        if ('children' in itemForNewLang) {
            (_a = itemForNewLang.children) === null || _a === void 0 ? void 0 : _a.forEach((c) => mergeWithExisting(c, itemForNewLang.id));
        }
    }
    for (let i = 0; i < languages.length; i++) {
        const language = languages[i];
        const itemsForLanguage = await handleLanguage(language);
        if (allCatalogueItems.length === 0) {
            allCatalogueItems.push(...itemsForLanguage);
        }
        else {
            /**
             * Remove catalogue path here, as we only want the default language
             * catalogue path to be in the spec
             */
            (0, __1.removeUnwantedFieldsFromThing)(itemsForLanguage, ['cataloguePath']);
            const rootItemId = await (0, __1.getTenantRootItemId)(context);
            itemsForLanguage.forEach((m) => mergeWithExisting(m, rootItemId));
        }
    }
    allCatalogueItems.sort(utils_1.byTreePosition);
    const fieldsToRemove = ['treePosition', multilingual_1.translationFieldIdentifier];
    if (!(options === null || options === void 0 ? void 0 : options.keepOriginalIds)) {
        fieldsToRemove.push('id');
    }
    return (0, __1.removeUnwantedFieldsFromThing)((0, utils_1.removeUnpublishedFolderFieldIndicator)(allCatalogueItems), fieldsToRemove);
}
exports.getAllCatalogueItems = getAllCatalogueItems;
