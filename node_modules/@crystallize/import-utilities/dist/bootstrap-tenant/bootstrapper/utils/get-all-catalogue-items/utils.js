"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.byTreePosition = exports.getItemById = exports.buildPathShouldBeIncludedValidator = exports.removeUnpublishedFolderFieldIndicator = exports.unpublishedFolderFieldIndicator = exports.getOnlyItemsWithPathStartingWith = void 0;
function getOnlyItemsWithPathStartingWith(basePath, allCatalogueItemsForLanguage) {
    if (basePath === '/') {
        return allCatalogueItemsForLanguage;
    }
    const ret = [];
    let foundExactFolderMatch = false;
    function handleLevel(item) {
        var _a;
        if (!foundExactFolderMatch) {
            if ((_a = item.cataloguePath) === null || _a === void 0 ? void 0 : _a.startsWith(basePath)) {
                if ('children' in item) {
                    foundExactFolderMatch = true;
                }
                ret.push(item);
            }
            else {
                const f = item;
                if (f.children) {
                    f.children.forEach(handleLevel);
                }
            }
        }
    }
    allCatalogueItemsForLanguage.forEach(handleLevel);
    return ret;
}
exports.getOnlyItemsWithPathStartingWith = getOnlyItemsWithPathStartingWith;
/**
 * Delete fields from object where the unpublishedFolderFieldIndicator
 * is part of an object. E.g.:
 * "name": {
 *   "en": "__unpublished_folder_indicator",
 *   "no-nb": "Toppmappe (updated)"
 * },
 * ... becomes ...
 * * "name": {
 *   "no-nb": "Toppmappe (updated)"
 * },
 */
exports.unpublishedFolderFieldIndicator = '__unpublished_folder_indicator';
function removeUnpublishedFolderFieldIndicator(items) {
    function handleItem(item) {
        var _a;
        // We only need to delete this from the translated fields, "name" for now
        if (typeof item.name === 'object') {
            const filteredName = {};
            Object.keys(item.name).forEach((language) => {
                const value = item.name[language];
                if (value !== exports.unpublishedFolderFieldIndicator) {
                    filteredName[language] = value;
                }
            });
            item.name = filteredName;
        }
        if ('children' in item) {
            item.children = (_a = item.children) === null || _a === void 0 ? void 0 : _a.map(handleItem);
        }
        return item;
    }
    return items.map(handleItem);
}
exports.removeUnpublishedFolderFieldIndicator = removeUnpublishedFolderFieldIndicator;
function buildPathShouldBeIncludedValidator(basePath = '') {
    return function validate(path) {
        if (!basePath || basePath === '/') {
            return {
                thisItem: true,
                descendants: true,
            };
        }
        const p = path || '';
        const thisItem = p.startsWith(basePath);
        return {
            thisItem,
            descendants: thisItem || basePath.startsWith(p),
        };
    };
}
exports.buildPathShouldBeIncludedValidator = buildPathShouldBeIncludedValidator;
function getItemById(items, id) {
    let found = null;
    function search(item) {
        var _a;
        if (!found) {
            if (item.id === id) {
                found = item;
            }
            else {
                if ('children' in item) {
                    (_a = item.children) === null || _a === void 0 ? void 0 : _a.forEach(search);
                }
            }
        }
    }
    items.forEach(search);
    return found;
}
exports.getItemById = getItemById;
function byTreePosition(a, b) {
    const aP = a.treePosition;
    const bP = b.treePosition;
    if (aP > bP) {
        return 1;
    }
    if (aP < bP) {
        return -1;
    }
    return 0;
}
exports.byTreePosition = byTreePosition;
