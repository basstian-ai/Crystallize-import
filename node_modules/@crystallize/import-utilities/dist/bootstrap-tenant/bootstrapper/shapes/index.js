"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.setShapes = exports.getExistingShapesForSpec = void 0;
const import_export_sdk_1 = require("@crystallize/import-export-sdk");
const utils_1 = require("../utils");
var Status;
(function (Status) {
    Status["created"] = "created";
    Status["updated"] = "updated";
    Status["error"] = "error";
    Status["deferred"] = "deferred";
})(Status || (Status = {}));
async function getExistingShapesForSpec(context) {
    var _a;
    const { query, variables } = (0, import_export_sdk_1.getManyShapesQuery)({
        tenantId: context.tenantId,
    }, { includeComponents: true });
    const existingShapes = await ((_a = context.client) === null || _a === void 0 ? void 0 : _a.pimApi(query, variables).then((res) => { var _a; return (_a = res === null || res === void 0 ? void 0 : res.shape) === null || _a === void 0 ? void 0 : _a.getMany; }));
    return existingShapes.map(function removeVariantComponentsForNoneProducts(shape) {
        if (shape.type !== 'product') {
            delete shape.variantComponents;
        }
        return shape;
    });
}
exports.getExistingShapesForSpec = getExistingShapesForSpec;
const shouldDefer = (data) => {
    var _a, _b, _c, _d, _e, _f;
    const filterRelations = (cmp) => {
        var _a, _b;
        return cmp.type === 'itemRelations' &&
            ((_b = (_a = cmp.config) === null || _a === void 0 ? void 0 : _a.acceptedShapeIdentifiers) === null || _b === void 0 ? void 0 : _b.length);
    };
    const filterChunks = (cmp) => {
        var _a;
        return cmp.type === 'contentChunk' &&
            ((_a = cmp.config.components.filter(filterRelations)) === null || _a === void 0 ? void 0 : _a.length);
    };
    const filterChoices = (cmp) => {
        var _a;
        return cmp.type === 'componentChoice' &&
            ((_a = cmp.config.choices.filter(filterRelations)) === null || _a === void 0 ? void 0 : _a.length);
    };
    return (!!((_a = data.components) === null || _a === void 0 ? void 0 : _a.filter(filterRelations).length) ||
        !!((_b = data.components) === null || _b === void 0 ? void 0 : _b.filter(filterChunks).length) ||
        !!((_c = data.components) === null || _c === void 0 ? void 0 : _c.filter(filterChoices).length) ||
        !!((_d = data.variantComponents) === null || _d === void 0 ? void 0 : _d.filter(filterRelations).length) ||
        !!((_e = data.variantComponents) === null || _e === void 0 ? void 0 : _e.filter(filterChunks).length) ||
        !!((_f = data.variantComponents) === null || _f === void 0 ? void 0 : _f.filter(filterChoices).length));
};
async function handleShape(data, context, onUpdate, isDeferred = false) {
    const s = Object.assign({}, data);
    let defer = false;
    if (!isDeferred && shouldDefer(data)) {
        delete s.components;
        delete s.variantComponents;
        defer = true;
    }
    try {
        const result = await (0, import_export_sdk_1.shape)(s).execute(context.client);
        if (!result) {
            onUpdate({
                error: {
                    code: 'CANNOT_HANDLE_SHAPE',
                    message: 'API did not return any result',
                },
            });
            return Status.error;
        }
        if (defer) {
            return Status.deferred;
        }
        return Status.updated;
    }
    catch (err) {
        if (context.config.logLevel === 'verbose') {
            console.error(err);
        }
        onUpdate({
            error: {
                code: 'CANNOT_HANDLE_SHAPE',
                message: err.message,
            },
        });
        return Status.error;
    }
}
const getExistingShapes = async (context) => {
    if (!context.client) {
        return [];
    }
    const { query, variables } = (0, import_export_sdk_1.getManyShapesQuery)({
        tenantId: context.tenantId,
    }, {
        includeComponents: true,
    });
    return context.client
        .pimApi(query, variables)
        .then((res) => { var _a; return ((_a = res === null || res === void 0 ? void 0 : res.shape) === null || _a === void 0 ? void 0 : _a.getMany) || []; });
};
async function setShapes({ spec, onUpdate, context, }) {
    if (!context.client) {
        throw new Error('missing @crystallize/js-api-client instace');
    }
    // Get all the shapes from the tenant
    const existingShapes = await getExistingShapes(context);
    const deferredShapes = [];
    if (!(spec === null || spec === void 0 ? void 0 : spec.shapes)) {
        return existingShapes;
    }
    let finished = 0;
    for (let i = 0; i < spec.shapes.length; i++) {
        const data = spec.shapes[i];
        // Ensure that the shape identifier is truncated
        data.identifier = (0, utils_1.validShapeIdentifier)(data.identifier, onUpdate);
        // Get existing shape
        const existingShapeConfig = existingShapes.find((e) => e.identifier === data.identifier);
        // Delete shape components (not variant components) before adding new ones
        if (existingShapeConfig) {
            // if (context.config.shapeComponents === 'replace') {
            //   try {
            //     await context.callPIM({
            //       query: `
            //         mutation CLEAR_SHAPE_COMPONENTS (
            //           $tenantId: ID!
            //           $identifier: String!
            //         ) {
            //           shape {
            //             update (
            //               tenantId: $tenantId
            //               identifier: $identifier
            //               input: {
            //                 components: []
            //               }
            //             ) {
            //               identifier
            //             }
            //           }
            //         }
            //       `,
            //       variables: {
            //         identifier: data.identifier,
            //         tenantId: context.tenantId,
            //       },
            //     })
            //   } catch (e) {
            //     console.log(e)
            //   }
            // }
            // else if (existingShapeConfig?.components) {
            // Merge in existing shape
            if (existingShapeConfig === null || existingShapeConfig === void 0 ? void 0 : existingShapeConfig.components) {
                const comps = data.components || [];
                data.components = [
                    ...existingShapeConfig.components.filter((c) => !comps.map((c) => c.id).includes(c.id)),
                    ...comps,
                ];
            }
        }
        const result = await handleShape(data, context, onUpdate);
        if (result === 'deferred') {
            deferredShapes.push(data);
        }
        else {
            finished++;
        }
        onUpdate({
            progress: finished / spec.shapes.length,
            message: `${data.name} (${data.identifier}): ${result}`,
        });
    }
    for (let i = 0; i < deferredShapes.length; i++) {
        const shape = deferredShapes[i];
        const result = await handleShape(shape, context, onUpdate, true);
        finished++;
        onUpdate({
            progress: finished / spec.shapes.length,
            message: `${shape.name} (${shape.identifier}): ${result}`,
        });
    }
    onUpdate({
        progress: 1,
    });
    return await getExistingShapes(context);
}
exports.setShapes = setShapes;
