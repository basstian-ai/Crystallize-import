"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleItem = void 0;
const utils_1 = require("../utils");
const createOrUpdateItem_1 = require("./createOrUpdateItem");
async function handleItem(item, index, rootItemId, context, onUpdate, finishedItems, totalItems) {
    if (!item) {
        return finishedItems;
    }
    let parentId = rootItemId;
    // updating the id and parentId of the item from the DB
    const itemAndParentId = await (0, utils_1.getItemId)({
        context,
        externalReference: item.externalReference,
        cataloguePath: item.cataloguePath,
        shapeIdentifier: item.shape,
        language: context.targetLanguage || context.defaultLanguage,
    });
    item.id = itemAndParentId.itemId;
    item._parentId = itemAndParentId.parentId;
    // if that's mention in the spec, we take the parent id
    if (item.parentExternalReference || item.parentCataloguePath) {
        const parentItemAndParentId = await (0, utils_1.getItemId)({
            context,
            externalReference: item.parentExternalReference,
            cataloguePath: item.parentCataloguePath,
            shapeIdentifier: item.shape,
            language: context.targetLanguage || context.defaultLanguage,
        });
        parentId = parentItemAndParentId.itemId || '';
        if (parentId == '') {
            parentId = context.fallbackFolderId;
            onUpdate({
                error: {
                    code: 'PARENT_FOLDER_NOT_FOUND',
                    message: `Cannot find the specified parent folder for item`,
                    item,
                },
            });
        }
    }
    // If the item exists in Crystallize already
    item._exists = Boolean(item.id);
    item.id = (await (0, createOrUpdateItem_1.createOrUpdateItem)(item, parentId || rootItemId, index + 1, onUpdate, context, rootItemId));
    finishedItems++;
    onUpdate({
        progress: finishedItems / totalItems,
        message: `Handled ${(0, utils_1.getTranslation)(item.name, context.targetLanguage || context.defaultLanguage)}`,
    });
    if (item.id) {
        /**
         * Store the item id for the cataloguePath. Very useful if the generated
         * cataloguePath is different than the one in the JSON spec
         */
        if (item.cataloguePath) {
            context.itemCataloguePathToIDMap.set(item.cataloguePath, {
                itemId: item.id,
                parentId: parentId || rootItemId,
            });
        }
        if (item.externalReference) {
            context.itemExternalReferenceToIDMap.set(item.externalReference, {
                itemId: item.id,
                parentId: parentId || rootItemId,
            });
        }
        if (item && 'children' in item) {
            const itm = item;
            if (itm.children) {
                for (let i = 0; i < itm.children.length; i++) {
                    finishedItems = await handleItem(itm.children[i], i, itm.id || '', context, onUpdate, finishedItems, totalItems);
                }
            }
        }
    }
    return finishedItems;
}
exports.handleItem = handleItem;
