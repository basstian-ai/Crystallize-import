"use strict";
var __rest = (this && this.__rest) || function (s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {
            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))
                t[p[i]] = s[p[i]];
        }
    return t;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createOrUpdateItem = void 0;
const graphql_1 = require("../../../graphql");
const utils_1 = require("../utils");
const get_topic_id_1 = require("../utils/get-topic-id");
const get_all_grids_1 = require("../utils/get-all-grids");
const has_item_relations_component_1 = require("../utils/has-item-relations-component");
const createComponentsInput_1 = require("./createComponentsInput");
const get_product_1 = require("../utils/get-product");
const build_update_variant_component_mutation_1 = require("../../../graphql/build-update-variant-component-mutation");
const handleJsonStockToStockInput_1 = require("./handleJsonStockToStockInput");
const handleJsonPriceToPriceInput_1 = require("./handleJsonPriceToPriceInput");
const getSubscriptionPlanMeteredVariables_1 = require("./getSubscriptionPlanMeteredVariables");
const getSubscriptionPlanPeriodId_1 = require("./getSubscriptionPlanPeriodId");
const subscriptionPlanPrincingJsonToInput_1 = require("./subscriptionPlanPrincingJsonToInput");
const createImagesInput_1 = require("./createImagesInput");
const getExistingTopicIdsForItem_1 = require("./getExistingTopicIdsForItem");
async function createOrUpdateItem(item, parentId, treePosition, onUpdate, context, rootItemId) {
    var _a, _b, _c, _d;
    // Create the object to store the component data in
    item._componentsData = {};
    if (!item.shape) {
        onUpdate({
            error: {
                code: 'SHAPE_ID_MISSING',
                message: `Missing shape identifier for item "${(0, utils_1.getTranslation)(item.name, context.targetLanguage || context.defaultLanguage)}". Got "${item.shape}"`,
            },
        });
        return null;
    }
    const allGrids = await (0, get_all_grids_1.getAllGrids)(context.targetLanguage || context.defaultLanguage, context);
    // Ensure shape identifier is not too long (max 64 characters)
    item.shape = (0, utils_1.validShapeIdentifier)(item.shape, onUpdate);
    // Get the shape type
    const shape = (_a = context.shapes) === null || _a === void 0 ? void 0 : _a.find((s) => s.identifier === item.shape);
    if (!shape) {
        onUpdate({
            error: {
                code: 'CANNOT_HANDLE_ITEM',
                message: `Skipping  "${(0, utils_1.getTranslation)(item.name, context.targetLanguage || context.defaultLanguage)}". Could not locate its shape (${item.shape}))`,
            },
        });
        return null;
    }
    async function createForLanguage(language) {
        if (!shape) {
            return;
        }
        item._topicsData = {};
        if (item.topics) {
            item._topicsData = {
                topicIds: await (0, get_topic_id_1.getTopicIds)({
                    topics: item.topics || [],
                    language: context.targetLanguage || context.defaultLanguage,
                    context,
                }),
            };
        }
        return context.callPIM((0, graphql_1.buildCreateItemQueryAndVariables)(Object.assign(Object.assign(Object.assign(Object.assign({ name: (0, utils_1.getTranslation)(item.name, language) || '', shapeIdentifier: item.shape, tenantId: context.tenantId }, (item.externalReference && {
            externalReference: item.externalReference,
        })), { tree: {
                parentId,
                position: treePosition,
            }, components: {} }), (item.topics && item._topicsData)), ((shape === null || shape === void 0 ? void 0 : shape.type) === 'product' && Object.assign({}, (await createProductItemMutation(language))))), 
        // @ts-expect-error this will be set. Don't worry.
        shape === null || shape === void 0 ? void 0 : shape.type, language));
    }
    async function updateForLanguage(language, itemId) {
        var _a, _b, _c, _d, _e;
        if (!shape || !itemId) {
            onUpdate({
                error: {
                    code: 'CANNOT_HANDLE_PRODUCT',
                    message: `Cannot update "${(0, utils_1.getTranslation)(item.name, language)}" for language "${language}". Missing shape or itemId`,
                    item,
                },
            });
            return;
        }
        if (item._componentsData) {
            item._componentsData[language] = await (0, createComponentsInput_1.createComponentsInput)({
                components: item.components,
                componentDefinitions: shape.components,
                language,
                grids: allGrids,
                context,
                onUpdate,
            });
        }
        const clearComponentsData = ((_a = item._componentsData) === null || _a === void 0 ? void 0 : _a[language]) === null;
        const updates = [];
        /**
         * If it is a product, we need to pull all the product
         * variants first, and then update each field.
         * We need to do this because there is (currently) not
         * any product.addVariant mutation
         */
        let existingProductVariants;
        if ((shape === null || shape === void 0 ? void 0 : shape.type) === 'product') {
            const existingProduct = await (0, get_product_1.getProduct)(language, itemId, context);
            existingProductVariants = existingProduct.variants;
            // Add vatType if it is not part of the item.
            // This eases the DX, as you don't _have_ to pass vatType
            // for existing products
            const productItem = item;
            if (!productItem.vatType) {
                productItem.vatType = existingProduct.vatType.name;
            }
            // Ensure that this is an array
            if (!productItem.variants) {
                productItem.variants = [];
            }
        }
        /**
         * Start with the basic item information
         */
        updates.push(async () => context.callPIM((0, graphql_1.buildUpdateItemQueryAndVariables)(itemId, Object.assign(Object.assign(Object.assign({ name: (0, utils_1.getTranslation)(item.name, language) || '' }, (item.topics && item._topicsData)), ((shape === null || shape === void 0 ? void 0 : shape.type) === 'product' && Object.assign({}, (await createProductItemMutation(language, existingProductVariants))))), (clearComponentsData && {
            components: {},
        })), shape.type, language)));
        /**
         * Create a single update component mutation on
         * each component. This will ensure that no
         * component data will be lost during the update
         */
        if ((_b = item._componentsData) === null || _b === void 0 ? void 0 : _b[language]) {
            Object.keys(item._componentsData[language]).forEach((componentId) => {
                var _a;
                const componentContent = (_a = item._componentsData) === null || _a === void 0 ? void 0 : _a[language][componentId];
                componentContent &&
                    !(0, has_item_relations_component_1.hasItemRelationsComponent)(componentContent) &&
                    updates.push(() => context.callPIM((0, graphql_1.buildUpdateItemComponentQueryAndVariables)({
                        itemId,
                        language,
                        input: Object.assign({ componentId }, componentContent),
                    })));
            });
        }
        if ((_c = item.variants) === null || _c === void 0 ? void 0 : _c.length) {
            const product = item;
            for (const variant of product.variants) {
                if (!variant._componentsData) {
                    variant._componentsData = {};
                }
                variant._componentsData[language] = await (0, createComponentsInput_1.createComponentsInput)({
                    components: variant.components,
                    componentDefinitions: shape.variantComponents,
                    language,
                    grids: allGrids,
                    context,
                    onUpdate,
                });
                if ((_d = variant._componentsData) === null || _d === void 0 ? void 0 : _d[language]) {
                    Object.keys((_e = variant._componentsData) === null || _e === void 0 ? void 0 : _e[language]).forEach((componentId) => {
                        var _a;
                        const componentContent = (_a = variant._componentsData) === null || _a === void 0 ? void 0 : _a[language][componentId];
                        componentContent &&
                            !(0, has_item_relations_component_1.hasItemRelationsComponent)(componentContent) &&
                            updates.push(() => context.callPIM((0, build_update_variant_component_mutation_1.buildUpdateVariantComponentQueryAndVariables)({
                                productId: itemId,
                                sku: variant.sku,
                                language,
                                input: Object.assign({ componentId }, componentContent),
                            })));
                    });
                }
            }
        }
        const responses = [];
        for (let i = 0; i < updates.length; i++) {
            responses.push(await updates[i]());
        }
        context.emit(utils_1.EVENT_NAMES.ITEM_UPDATED, {
            id: itemId,
            name: (0, utils_1.getTranslation)(item.name, language),
            language,
            shape: {
                type: shape.type,
                identifier: shape.identifier,
            },
            from: item,
        });
        return responses;
    }
    function createProductBaseInfo() {
        var _a;
        const product = item;
        const vatType = (_a = context.vatTypes) === null || _a === void 0 ? void 0 : _a.find((v) => { var _a; return ((_a = v.name) === null || _a === void 0 ? void 0 : _a.toLowerCase()) === product.vatType.toLowerCase(); });
        if (!vatType) {
            onUpdate({
                error: {
                    code: 'CANNOT_HANDLE_PRODUCT',
                    message: `Cannot create product "${product.name}". Vat type "${product.vatType}" does not exist`,
                    item,
                },
            });
            return;
        }
        return {
            vatTypeId: vatType.id || '',
        };
    }
    async function createProductVariant(jsonVariant, language, shape, allGrids, existingProductVariant) {
        var _a, _b;
        let attributes;
        if (jsonVariant.attributes) {
            attributes = Object.keys(jsonVariant.attributes).map((attribute) => {
                var _a;
                return ({
                    attribute,
                    value: ((_a = jsonVariant.attributes) === null || _a === void 0 ? void 0 : _a[attribute]) || '',
                });
            });
        }
        const _c = existingProductVariant || {}, { priceVariants: existingProductVariantPriceVariants, stockLocations: existingProductVariantStockLocations } = _c, restOfExistingProductVariant = __rest(_c, ["priceVariants", "stockLocations"]);
        const variant = Object.assign(Object.assign(Object.assign({}, restOfExistingProductVariant), { name: (0, utils_1.getTranslation)(jsonVariant.name, language), sku: jsonVariant.sku, isDefault: jsonVariant.isDefault || false, stockLocations: (0, handleJsonStockToStockInput_1.handleJsonStockToStockInput)({
                jsonStock: jsonVariant.stock,
                existingProductVariantStockLocations,
            }), priceVariants: (0, handleJsonPriceToPriceInput_1.handleJsonPriceToPriceInput)({
                jsonPrice: jsonVariant.price,
                existingProductVariantPriceVariants,
            }) }), (attributes && { attributes }));
        delete variant.components;
        if (shape.variantComponents) {
            jsonVariant._componentsData = {};
            if (jsonVariant.components) {
                jsonVariant._componentsData[language] = await (0, createComponentsInput_1.createComponentsInput)({
                    components: jsonVariant.components,
                    componentDefinitions: shape.variantComponents,
                    language,
                    grids: allGrids,
                    context,
                    onUpdate,
                });
            }
            if ((_a = jsonVariant._componentsData) === null || _a === void 0 ? void 0 : _a[language]) {
                Object.keys((_b = jsonVariant._componentsData) === null || _b === void 0 ? void 0 : _b[language]).forEach((componentId) => {
                    var _a, _b;
                    const componentContent = (_a = jsonVariant._componentsData) === null || _a === void 0 ? void 0 : _a[language][componentId];
                    (variant === null || variant === void 0 ? void 0 : variant.components) || (variant.components = []);
                    componentContent &&
                        !(0, has_item_relations_component_1.hasItemRelationsComponent)(componentContent) &&
                        ((_b = variant === null || variant === void 0 ? void 0 : variant.components) === null || _b === void 0 ? void 0 : _b.push(Object.assign({ componentId }, componentContent)));
                });
            }
            else {
                delete variant.components;
            }
        }
        if (jsonVariant.images) {
            variant.images = await (0, createImagesInput_1.createImagesInput)({
                images: jsonVariant.images,
                language,
                context,
                onUpdate,
            });
        }
        // This causes an internal error at the API right now. Setting the value to an empty
        // array has the same outcome as setting it to null
        if (variant.images === null) {
            variant.images = [];
        }
        if (jsonVariant.subscriptionPlans) {
            variant.subscriptionPlans = jsonVariant.subscriptionPlans.map((sP) => {
                const meteredVariables = (0, getSubscriptionPlanMeteredVariables_1.getSubscriptionPlanMeteredVariables)({
                    planIdentifier: sP.identifier,
                    context,
                });
                return {
                    identifier: sP.identifier,
                    periods: sP.periods.map((p) => {
                        const id = (0, getSubscriptionPlanPeriodId_1.getSubscriptionPlanPeriodId)({
                            planIdentifier: sP.identifier,
                            periodName: p.name,
                            context,
                        });
                        if (!id) {
                            throw new Error('Plan period id is null');
                        }
                        return Object.assign(Object.assign({ id }, (p.initial && {
                            initial: (0, subscriptionPlanPrincingJsonToInput_1.subscriptionPlanPrincingJsonToInput)(p.initial, meteredVariables),
                        })), { recurring: (0, subscriptionPlanPrincingJsonToInput_1.subscriptionPlanPrincingJsonToInput)(p.recurring, meteredVariables) });
                    }),
                };
            });
        }
        return variant;
    }
    async function createProductItemMutation(language, existingProductVariants) {
        var _a;
        const product = item;
        const variants = [];
        const inp = Object.assign(Object.assign({}, createProductBaseInfo()), { variants });
        // Add existing product variants
        if (existingProductVariants) {
            inp.variants.push(...existingProductVariants.map((_a) => {
                var { priceVariants, stockLocations, components } = _a, rest = __rest(_a, ["priceVariants", "stockLocations", "components"]);
                return (Object.assign(Object.assign({}, rest), { priceVariants: priceVariants === null || priceVariants === void 0 ? void 0 : priceVariants.map((p) => ({
                        identifier: p.identifier,
                        price: p.price,
                    })), stockLocations: stockLocations === null || stockLocations === void 0 ? void 0 : stockLocations.map((p) => ({
                        identifier: p.identifier,
                        stock: p.stock,
                        meta: p.meta,
                    })) }));
            }));
        }
        for (let i = 0; i < product.variants.length; i++) {
            const vr = product.variants[i];
            let existingProductVariant = existingProductVariants === null || existingProductVariants === void 0 ? void 0 : existingProductVariants.find((v) => v.sku === vr.sku ||
                (v.externalReference && v.externalReference === vr.externalReference));
            if (!existingProductVariant && vr.externalReference) {
                existingProductVariant = existingProductVariants === null || existingProductVariants === void 0 ? void 0 : existingProductVariants.find((v) => v.externalReference === vr.externalReference);
            }
            const variant = await createProductVariant(vr, language, (_a = context.shapes) === null || _a === void 0 ? void 0 : _a.find((s) => s.identifier === item.shape), allGrids, existingProductVariant);
            if (existingProductVariant) {
                const index = inp.variants.findIndex((v) => v.sku === vr.sku ||
                    (v.externalReference &&
                        v.externalReference === vr.externalReference));
                inp.variants[index] = variant;
            }
            else {
                inp.variants.push(variant);
            }
        }
        // Ensure that only one is set as the default
        const defaultVariants = inp.variants.filter((v) => v.isDefault);
        if (defaultVariants.length !== 1) {
            inp.variants.forEach((v) => (v.isDefault = false));
            inp.variants[0].isDefault = true;
        }
        return inp;
    }
    let itemId = item.id;
    // Get new topics
    item._topicsData = {
        topicIds: await (0, get_topic_id_1.getTopicIds)({
            topics: item.topics || [],
            language: context.targetLanguage || context.defaultLanguage,
            context,
        }),
    };
    if (itemId) {
        /**
         * Pull the item version info now and store it in the
         * context cace before any changes are made to it.
         * The version info will be read later before a
         * potential publishing of an item
         */
        if (context.config.itemPublish === 'auto') {
            await (0, utils_1.getItemVersionsForLanguages)({
                itemId,
                languages: context.languages.map((l) => l.code),
                context,
            });
        }
        const realRootItemId = await (0, utils_1.getTenantRootItemId)(context);
        if ((_b = item._options) === null || _b === void 0 ? void 0 : _b.moveToRoot) {
            if (item._parentId !== rootItemId) {
                await context.callPIM({
                    query: (0, graphql_1.buildMoveItemMutation)(itemId, {
                        parentId: rootItemId,
                    }),
                });
            }
        }
        else if (item._exists &&
            item._parentId !== parentId &&
            itemId !== parentId &&
            parentId !== realRootItemId // Do not move items to root unless _moveToRoot is set
        ) {
            /**
             * Move the item if it is a part of a children array,
             * or if item.parentExternalReference is passed
             */
            await context.callPIM({
                query: (0, graphql_1.buildMoveItemMutation)(itemId, {
                    parentId,
                    position: treePosition,
                }),
            });
        }
        // Merge in existing topic
        if (item.topics && context.config.itemTopics === 'amend') {
            const existingTopicIds = await (0, getExistingTopicIdsForItem_1.getExistingTopicIdsForItem)(itemId, context.targetLanguage || context.defaultLanguage, context);
            item._topicsData.topicIds = Array.from(new Set([...existingTopicIds, ...item._topicsData.topicIds]));
        }
        const responses = await updateForLanguage(context.targetLanguage || context.defaultLanguage, itemId);
        if (responses === null || responses === void 0 ? void 0 : responses.length) {
            responses.forEach((response) => {
                var _a, _b;
                const result = (_b = (_a = response === null || response === void 0 ? void 0 : response.data) === null || _a === void 0 ? void 0 : _a[shape === null || shape === void 0 ? void 0 : shape.type]) === null || _b === void 0 ? void 0 : _b.update;
                if (result) {
                    const { id, externalReference, tree: { path }, } = result;
                    context.itemCataloguePathToIDMap.set(item.cataloguePath || path, {
                        itemId: id,
                    });
                    if (externalReference) {
                        context.itemExternalReferenceToIDMap.set(externalReference, {
                            itemId: id,
                        });
                    }
                }
            });
        }
    }
    else {
        // Ensure a name is set for the default language (required by the API)
        if (!(0, utils_1.getTranslation)(item.name, context.targetLanguage || context.defaultLanguage)) {
            onUpdate({
                error: {
                    code: 'CANNOT_HANDLE_ITEM',
                    message: `Item name cannot be empty for the default language. Item id: "${item.id}"`,
                },
            });
            throw new Error(`Item name cannot be empty for the default language`);
        }
        /**
         * Ensure that variants are present when creating
         * a product
         */
        if (shape.type === 'product') {
            const product = item;
            if (!product.variants || product.variants.length === 0) {
                onUpdate({
                    error: {
                        code: 'CANNOT_HANDLE_PRODUCT',
                        message: `Skipping  "${(0, utils_1.getTranslation)(item.name, context.targetLanguage || context.defaultLanguage)}". No variants defined for product`,
                        item,
                    },
                });
                return null;
            }
        }
        const response = await createForLanguage(context.targetLanguage || context.defaultLanguage);
        const result = (_d = (_c = response === null || response === void 0 ? void 0 : response.data) === null || _c === void 0 ? void 0 : _c[shape === null || shape === void 0 ? void 0 : shape.type]) === null || _d === void 0 ? void 0 : _d.create;
        if (result) {
            const { id, externalReference, tree: { path }, } = result;
            context.itemCataloguePathToIDMap.set(item.cataloguePath || path, {
                itemId: id,
            });
            if (externalReference) {
                context.itemExternalReferenceToIDMap.set(externalReference, {
                    itemId: id,
                });
            }
            itemId = id;
            const language = context.targetLanguage || context.defaultLanguage;
            context.emit(utils_1.EVENT_NAMES.ITEM_CREATED, {
                id,
                name: (0, utils_1.getTranslation)(item.name, language),
                language,
                shape: {
                    type: shape.type,
                    identifier: shape.identifier,
                },
                from: item,
            });
            // Set the component data for the item
            await updateForLanguage(context.targetLanguage || context.defaultLanguage, itemId);
        }
    }
    if (!itemId) {
        onUpdate({
            error: {
                code: 'CANNOT_HANDLE_ITEM',
                message: `Could not create or update item "${(0, utils_1.getTranslation)(item.name, context.targetLanguage || context.defaultLanguage)}"`,
            },
        });
        return null;
    }
    // Handle remaining languages
    const remainingLanguages = context.languages
        .filter((l) => !l.isDefault)
        .map((l) => l.code);
    for (let i = 0; i < remainingLanguages.length; i++) {
        await updateForLanguage(remainingLanguages[i], itemId);
    }
    return itemId;
}
exports.createOrUpdateItem = createOrUpdateItem;
