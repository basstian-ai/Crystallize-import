"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createComponentsInput = void 0;
const utils_1 = require("../utils");
const createImagesInput_1 = require("./createImagesInput");
const createVideosInput_1 = require("./createVideosInput");
const createFilesInput_1 = require("./createFilesInput");
const createRichTextInput_1 = require("./createRichTextInput");
async function createComponentsInput(props) {
    const { components, componentDefinitions, language, grids, context, onUpdate, } = props;
    // Explicit `null` clears all components data
    if (components === null) {
        return null;
    }
    // Undefined implies no action to be taken on components
    if (!components) {
        return undefined;
    }
    const input = {};
    async function createComponentInput(componentDefinition, component, context) {
        var _a, _b, _c;
        switch (componentDefinition === null || componentDefinition === void 0 ? void 0 : componentDefinition.type) {
            case 'boolean': {
                const b = component;
                if (!b) {
                    return {
                        boolean: null,
                    };
                }
                const inp = {
                    boolean: {
                        value: b,
                    },
                };
                return inp;
            }
            case 'singleLine': {
                const inp = {
                    singleLine: {
                        text: (0, utils_1.getTranslation)(component, language),
                    },
                };
                return inp;
            }
            case 'numeric': {
                const n = component;
                if (!n) {
                    return {
                        numeric: null,
                    };
                }
                const inp = {
                    numeric: {
                        number: n.number,
                        unit: (_a = n.unit) !== null && _a !== void 0 ? _a : '',
                    },
                };
                return inp;
            }
            case 'location': {
                const l = component;
                if (!l) {
                    return {
                        location: null,
                    };
                }
                const inp = {
                    location: {
                        lat: l.lat,
                        long: l.long,
                    },
                };
                return inp;
            }
            case 'datetime': {
                const d = component;
                if (!d) {
                    return {
                        datetime: null,
                    };
                }
                const parsedDate = new Date(d);
                const inp = {
                    datetime: {
                        datetime: parsedDate.toISOString(),
                    },
                };
                return inp;
            }
            case 'images': {
                const images = component;
                const inp = {
                    images: await (0, createImagesInput_1.createImagesInput)({
                        images,
                        language,
                        onUpdate,
                        context,
                    }),
                };
                return inp;
            }
            case 'videos': {
                const videos = component;
                const inp = {
                    videos: await (0, createVideosInput_1.createVideosInput)({
                        videos,
                        language,
                        onUpdate,
                        context,
                    }),
                };
                return inp;
            }
            case 'files': {
                const files = component;
                const inp = {
                    files: await (0, createFilesInput_1.createFilesInput)({
                        files,
                        language,
                        onUpdate,
                        context,
                    }),
                };
                return inp;
            }
            case 'richText': {
                const inp = (0, createRichTextInput_1.createRichTextInput)(component, language);
                if (Object.keys(inp).length > 0) {
                    return {
                        richText: inp,
                    };
                }
                break;
            }
            case 'selection': {
                const inp = {
                    selection: {
                        keys: [], // Todo
                    },
                };
                const s = component;
                if (typeof s === 'string') {
                    inp.selection.keys.push(s);
                }
                else if (Array.isArray(s)) {
                    s.forEach((key) => inp.selection.keys.push(key));
                }
                return inp;
            }
            case 'paragraphCollection': {
                const inp = {
                    paragraphCollection: {
                        paragraphs: [],
                    },
                };
                const paragraphs = component;
                for (let i = 0; i < (paragraphs === null || paragraphs === void 0 ? void 0 : paragraphs.length); i++) {
                    const { title, body, images, videos } = paragraphs[i];
                    inp.paragraphCollection.paragraphs.push(Object.assign(Object.assign(Object.assign({ title: {
                            text: (0, utils_1.getTranslation)(title, language),
                        } }, (body && { body: (0, createRichTextInput_1.createRichTextInput)(body, language) })), (images && {
                        images: await (0, createImagesInput_1.createImagesInput)({
                            images,
                            language,
                            context,
                            onUpdate,
                        }),
                    })), (videos && {
                        videos: await (0, createVideosInput_1.createVideosInput)({
                            videos,
                            language,
                            context,
                            onUpdate,
                        }),
                    })));
                }
                if (Object.keys(inp).length > 0) {
                    return inp;
                }
                break;
            }
            case 'propertiesTable': {
                const inp = {
                    propertiesTable: {
                        sections: [],
                    },
                };
                const sections = component || [];
                sections.forEach((section) => {
                    var _a;
                    const properties = [];
                    if (section.properties) {
                        Object.keys(section.properties).forEach((key) => {
                            var _a;
                            properties.push({
                                key,
                                value: (_a = section.properties) === null || _a === void 0 ? void 0 : _a[key],
                            });
                        });
                    }
                    (_a = inp.propertiesTable.sections) === null || _a === void 0 ? void 0 : _a.push({
                        title: section.title,
                        properties,
                    });
                });
                return inp;
            }
            case 'componentChoice': {
                const choice = component;
                const [selectedComponentId] = Object.keys(choice);
                if (!selectedComponentId) {
                    return {
                        componentChoice: null,
                    };
                }
                const componentConfig = componentDefinition.config;
                const selectedComponentDefinition = componentConfig.choices.find((c) => c.id === selectedComponentId);
                const content = await createComponentInput(selectedComponentDefinition, choice[selectedComponentId], context);
                const inp = {
                    componentChoice: Object.assign({ componentId: selectedComponentId }, content),
                };
                return inp;
            }
            case 'itemRelations': {
                const inp = {
                    itemRelations: {
                        itemIds: [],
                        skus: [], // Will be populated later
                    },
                };
                return inp;
                return undefined;
            }
            case 'gridRelations': {
                const gridsComponent = component;
                const gridIds = [];
                gridsComponent.forEach((g) => {
                    const found = grids.find((a) => (0, utils_1.getTranslation)(a.name, language) ===
                        (0, utils_1.getTranslation)(g.name, language));
                    if (found === null || found === void 0 ? void 0 : found.id) {
                        gridIds.push(found.id);
                    }
                    else {
                        const err = {
                            error: `Could not find grid with name "${g.name}". Skipping the grid relation.`,
                            willRetry: false,
                            type: 'error',
                        };
                        context.emit(utils_1.EVENT_NAMES.ERROR, err);
                    }
                });
                const inp = {
                    gridRelations: {
                        gridIds,
                    },
                };
                return inp;
            }
            case 'contentChunk': {
                const chunks = component || [];
                const inp = {
                    contentChunk: {
                        chunks: [],
                    },
                };
                for (let i = 0; i < (chunks === null || chunks === void 0 ? void 0 : chunks.length); i++) {
                    const newChunk = [];
                    const chunk = chunks[i];
                    const chunkKeys = Object.keys(chunk);
                    for (let x = 0; x < chunkKeys.length; x++) {
                        const componentId = chunkKeys[x];
                        const selectedComponentDefinition = (_c = (_b = componentDefinition.config) === null || _b === void 0 ? void 0 : _b.components) === null || _c === void 0 ? void 0 : _c.find((c) => c.id === componentId);
                        if (selectedComponentDefinition) {
                            const content = await createComponentInput(selectedComponentDefinition, chunk[componentId], context);
                            if (content) {
                                newChunk.push(Object.assign({ componentId }, content));
                            }
                        }
                    }
                    if (newChunk.length > 0) {
                        inp.contentChunk.chunks.push(newChunk);
                    }
                }
                return inp;
            }
        }
    }
    const componentIds = Object.keys(components);
    /**
     * If you don't supply any components, let's not continue.
     * The intention of the user is probably to only update
     * any provided components
     */
    if (componentIds.length === 0) {
        return undefined;
    }
    for (let i = 0; i < componentIds.length; i++) {
        const componentId = componentIds[i];
        const componentDefinition = componentDefinitions === null || componentDefinitions === void 0 ? void 0 : componentDefinitions.find((c) => c.id === componentId);
        if (componentDefinition && components) {
            if (componentId in components) {
                const component = components === null || components === void 0 ? void 0 : components[componentId];
                /**
                 * Make sure we don't just do a truthy check here,
                 * because true & "" & 0 are all valid content
                 */
                if (typeof component !== 'undefined') {
                    const content = await createComponentInput(componentDefinition, component, context);
                    if (typeof content !== 'undefined') {
                        input[componentId] = Object.assign({ componentId }, content);
                    }
                }
            }
        }
    }
    return input;
}
exports.createComponentsInput = createComponentsInput;
