"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Bootstrapper = exports.createSpecDefaults = void 0;
const graphql_tag_1 = __importDefault(require("graphql-tag"));
const events_1 = require("events");
const immer_1 = __importDefault(require("immer"));
// @ts-expect-error there are no types for 'duration'
const duration_1 = __importDefault(require("duration"));
__exportStar(require("./utils"), exports);
const utils_1 = require("./utils");
const shapes_1 = require("./shapes");
const price_variants_1 = require("./price-variants");
const languages_1 = require("./languages");
const vat_types_1 = require("./vat-types");
const topics_1 = require("./topics");
const setItems_1 = require("./items/setItems");
const get_all_catalogue_items_1 = require("./utils/get-all-catalogue-items");
const get_all_grids_1 = require("./utils/get-all-grids");
const grids_1 = require("./grids");
const stock_locations_1 = require("./stock-locations");
const subscription_plans_1 = require("./subscription-plans");
const api_1 = require("./utils/api");
const orders_1 = require("./orders");
const customers_1 = require("./customers");
const js_api_client_1 = require("@crystallize/js-api-client");
const get_all_orders_1 = require("./utils/get-all-orders");
const get_all_customers_1 = require("./utils/get-all-customers");
exports.createSpecDefaults = {
    shapes: true,
    grids: true,
    items: true,
    languages: true,
    priceVariants: true,
    vatTypes: true,
    subscriptionPlans: true,
    topicMaps: true,
    stockLocations: true,
    orders: false,
    customers: false,
    onUpdate: () => null,
};
function defaultAreaStatus() {
    return {
        progress: 0,
        warnings: [],
    };
}
class Bootstrapper extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.SPEC = null;
        this.PIMAPIManager = null;
        this.catalogueAPIManager = null;
        this.searchAPIManager = null;
        this.ordersAPIManager = null;
        this.tenantIdentifier = '';
        this.env = 'prod';
        this.context = {
            defaultLanguage: 'en',
            languages: [],
            config: {
                experimental: {},
            },
            /**
             * If it should allow for using cache when resolving
             * externalReference to item id, or topic paths to
             * topic id
             */
            useReferenceCache: false,
            /**
             * A map keeping a reference of all of the items in
             * the current spec and their (possible) item id
             */
            itemCataloguePathToIDMap: new Map(),
            /**
             * A map keeping a reference of all of the items in
             * the current spec and their (possible) item id
             */
            itemExternalReferenceToIDMap: new Map(),
            /**
             * A map keeping a reference of all of the items in
             * the current spec and their (possible) item versions
             */
            itemVersions: new Map(),
            tenantId: '',
            tenantIdentifier: '',
            fallbackFolderId: '',
            /**
             * A map keeping a reference of all of the topics in the current
             * spec and their id.
             */
            topicPathToIDMap: new Map(),
            fileUploader: new utils_1.FileUploadManager(),
            uploadFileFromUrl: (url, fileName) => this.context.fileUploader.uploadFromUrl(url, fileName),
            callPIM: () => Promise.resolve({ data: {} }),
            callCatalogue: () => Promise.resolve({ data: {} }),
            callSearch: () => Promise.resolve({ data: {} }),
            callOrders: () => Promise.resolve({ data: {} }),
            emit: (name, message) => {
                this.emit(name, message);
            },
        };
        this.config = {
            itemTopics: 'amend',
            itemPublish: 'auto',
            shapeComponents: 'amend',
            logLevel: 'silent',
            experimental: {},
            skipPublication: false
        };
        this.status = {
            media: defaultAreaStatus(),
            shapes: defaultAreaStatus(),
            grids: defaultAreaStatus(),
            items: defaultAreaStatus(),
            languages: defaultAreaStatus(),
            customers: defaultAreaStatus(),
            orders: defaultAreaStatus(),
            priceVariants: defaultAreaStatus(),
            vatTypes: defaultAreaStatus(),
            subscriptionPlans: defaultAreaStatus(),
            topicMaps: defaultAreaStatus(),
            stockLocations: defaultAreaStatus(),
        };
        this.getStatus = () => this.status;
        this.setSessionId = (sessionId) => {
            // PIM
            this.PIMAPIManager = (0, api_1.createAPICaller)({
                uri: `https://${this.env === 'dev'
                    ? 'pim-dev.crystallize.digital'
                    : 'pim.crystallize.com'}/graphql`,
                errorNotifier: (error) => {
                    this.emit(utils_1.EVENT_NAMES.ERROR, error);
                },
            });
            this.PIMAPIManager.CRYSTALLIZE_SESSION_ID = sessionId;
            this.context.callPIM = this.PIMAPIManager.push;
        };
        this.setAccessToken = (ACCESS_TOKEN_ID, ACCESS_TOKEN_SECRET) => {
            // PIM
            this.PIMAPIManager = (0, api_1.createAPICaller)({
                uri: `https://${this.env === 'dev'
                    ? 'pim-dev.crystallize.digital'
                    : 'pim.crystallize.com'}/graphql`,
                errorNotifier: (error) => {
                    this.emit(utils_1.EVENT_NAMES.ERROR, error);
                },
            });
            this.PIMAPIManager.CRYSTALLIZE_ACCESS_TOKEN_ID = ACCESS_TOKEN_ID;
            this.PIMAPIManager.CRYSTALLIZE_ACCESS_TOKEN_SECRET = ACCESS_TOKEN_SECRET;
            this.context.callPIM = this.PIMAPIManager.push;
        };
        this.setTenantIdentifier = async (tenantIdentifier) => {
            this.context.tenantIdentifier = tenantIdentifier;
            this.tenantIdentifier = tenantIdentifier;
            // Clear existing maps if the tenant is changed
            this.context.itemCataloguePathToIDMap = new Map();
            this.context.itemExternalReferenceToIDMap = new Map();
            this.context.topicPathToIDMap = new Map();
        };
        this.getTenantBasics = async () => {
            var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
            /**
             * Allow for access tokens to be set synchronosly after the
             * the setTenantIdentifier is set
             */
            await (0, utils_1.sleep)(5);
            const r = await this.context.callPIM({
                query: (0, graphql_tag_1.default) `
          {
            tenant {
              get(identifier: "${this.context.tenantIdentifier}") {
                id
                identifier
                staticAuthToken
                defaults {
                  language
                }
              }
            }
          }
        `,
            });
            const tenant = (_b = (_a = r === null || r === void 0 ? void 0 : r.data) === null || _a === void 0 ? void 0 : _a.tenant) === null || _b === void 0 ? void 0 : _b.get;
            if (!tenant) {
                const error = {
                    error: `⛔️ You do not have access to tenant "${this.context.tenantIdentifier}" ⛔️`,
                    willRetry: false,
                };
                this.emit(utils_1.EVENT_NAMES.ERROR, error);
                return false;
            }
            else {
                this.context.tenantId = tenant.id;
                this.context.fileUploader.context = this.context;
                this.context.defaultLanguage = tenant.defaults.language;
                const baseUrl = `https://${this.env === 'dev'
                    ? 'api-dev.crystallize.digital'
                    : 'api.crystallize.com'}/${this.context.tenantIdentifier}`;
                // this is PIM CLIENT only for now....
                // we should have this PER client like the following
                const client = (0, js_api_client_1.createClient)({
                    tenantIdentifier: this.context.tenantIdentifier,
                    tenantId: this.context.tenantId,
                    accessTokenId: (_c = this.PIMAPIManager) === null || _c === void 0 ? void 0 : _c.CRYSTALLIZE_ACCESS_TOKEN_ID,
                    accessTokenSecret: (_d = this.PIMAPIManager) === null || _d === void 0 ? void 0 : _d.CRYSTALLIZE_ACCESS_TOKEN_SECRET,
                    sessionId: (_e = this.PIMAPIManager) === null || _e === void 0 ? void 0 : _e.CRYSTALLIZE_SESSION_ID,
                    origin: this.env === 'dev' ? '-dev.crystallize.digital' : '.crystallize.com',
                });
                this.context.client = (0, js_api_client_1.createMassCallClient)(client, {});
                // Catalogue
                this.catalogueAPIManager = (0, api_1.createAPICaller)({
                    uri: `${baseUrl}/catalogue`,
                    errorNotifier: (error) => {
                        this.emit(utils_1.EVENT_NAMES.ERROR, error);
                    },
                    logLevel: this.config.logLevel,
                });
                this.catalogueAPIManager.CRYSTALLIZE_STATIC_AUTH_TOKEN = tenant.staticAuthToken;
                this.catalogueAPIManager.CRYSTALLIZE_ACCESS_TOKEN_ID = `${(_f = this.PIMAPIManager) === null || _f === void 0 ? void 0 : _f.CRYSTALLIZE_ACCESS_TOKEN_ID}`;
                this.catalogueAPIManager.CRYSTALLIZE_ACCESS_TOKEN_SECRET = `${(_g = this.PIMAPIManager) === null || _g === void 0 ? void 0 : _g.CRYSTALLIZE_ACCESS_TOKEN_SECRET}`;
                this.context.callCatalogue = this.catalogueAPIManager.push;
                // Search
                this.searchAPIManager = (0, api_1.createAPICaller)({
                    uri: `${baseUrl}/search`,
                    errorNotifier: (error) => {
                        this.emit(utils_1.EVENT_NAMES.ERROR, error);
                    },
                    logLevel: this.config.logLevel,
                });
                this.searchAPIManager.CRYSTALLIZE_STATIC_AUTH_TOKEN = tenant.staticAuthToken;
                this.searchAPIManager.CRYSTALLIZE_ACCESS_TOKEN_ID = `${(_h = this.PIMAPIManager) === null || _h === void 0 ? void 0 : _h.CRYSTALLIZE_ACCESS_TOKEN_ID}`;
                this.searchAPIManager.CRYSTALLIZE_ACCESS_TOKEN_SECRET = `${(_j = this.PIMAPIManager) === null || _j === void 0 ? void 0 : _j.CRYSTALLIZE_ACCESS_TOKEN_SECRET}`;
                this.context.callSearch = this.searchAPIManager.push;
                // Orders
                this.ordersAPIManager = (0, api_1.createAPICaller)({
                    uri: `https://${this.env === 'dev'
                        ? 'api-dev.crystallize.digital'
                        : 'api.crystallize.com'}/${this.tenantIdentifier}/orders`,
                    errorNotifier: (error) => {
                        this.emit(utils_1.EVENT_NAMES.ERROR, error);
                    },
                });
                this.ordersAPIManager.CRYSTALLIZE_ACCESS_TOKEN_ID = (_k = this.PIMAPIManager) === null || _k === void 0 ? void 0 : _k.CRYSTALLIZE_ACCESS_TOKEN_ID;
                this.ordersAPIManager.CRYSTALLIZE_ACCESS_TOKEN_SECRET = (_l = this.PIMAPIManager) === null || _l === void 0 ? void 0 : _l.CRYSTALLIZE_ACCESS_TOKEN_SECRET;
                this.context.callOrders = this.ordersAPIManager.push;
                // Set log level late so that we'll catch late changes to the config
                if (this.PIMAPIManager && this.config.logLevel) {
                    this.PIMAPIManager.logLevel = this.config.logLevel;
                }
                return true;
            }
        };
    }
    setTargetLanguage(targetLanguageCode) {
        if (this.config.multilingual) {
            console.warn('⚠️ Setting the target language with multilingual mode enabled has no effect');
        }
        this.context.targetLanguage = targetLanguageCode;
    }
    setSpec(spec) {
        this.SPEC = spec;
    }
    /**
     * Folder to import items to if the target parent can't be found.
     *
     * @param id folder id
     */
    setFallbackFolderId(id) {
        this.context.fallbackFolderId = id;
    }
    async ensureTenantExists() {
        var _a, _b, _c, _d;
        /**
         * Allow for access tokens to be set synchronosly after the
         * the setTenantIdentifier is set
         */
        await (0, utils_1.sleep)(5);
        if (!this.tenantIdentifier) {
            throw new Error('tenantIdentifier is not set. Use bootstrapper.setTenantIdentifier(<identifier>)');
        }
        const identifier = this.tenantIdentifier;
        const resultGetTenant = await ((_a = this.PIMAPIManager) === null || _a === void 0 ? void 0 : _a.push({
            query: `
      query ($identifier: String!) {
        tenant {
          get(identifier: $identifier) {
            identifier
          }
        }
      }`,
            variables: {
                identifier,
            },
            // No need to report for this query, as it will error out if the tenant does not exist
            suppressErrors: true,
        }));
        const match = ((_c = (_b = resultGetTenant === null || resultGetTenant === void 0 ? void 0 : resultGetTenant.data) === null || _b === void 0 ? void 0 : _b.tenant) === null || _c === void 0 ? void 0 : _c.get) || null;
        if (match) {
            return true;
        }
        // Attempt to create the tenant
        const resultCreate = await ((_d = this.PIMAPIManager) === null || _d === void 0 ? void 0 : _d.push({
            query: `
        mutation ($identifier: String!) {
          tenant {
            create (
              input: {
                identifier: $identifier
                name: $identifier
              }
            ) {
              identifier
            }
          }
        }`,
            variables: {
                identifier,
            },
        }));
        // This tenant identifier exists, but you do not have access
        if (resultCreate === null || resultCreate === void 0 ? void 0 : resultCreate.errors) {
            return false;
        }
        return true;
    }
    async createSpec(props = exports.createSpecDefaults) {
        var _a;
        const spec = {};
        try {
            await this.getTenantBasics();
            // Store the config in the context for easy access
            this.context.config = this.config;
            const tenantLanguageSettings = await (0, languages_1.getTenantSettings)(this.context);
            // Languages
            const availableLanguages = tenantLanguageSettings.availableLanguages
                .map((l) => ({
                code: l.code,
                name: l.name,
                isDefault: l.code === tenantLanguageSettings.defaultLanguage,
            }))
                .sort((a) => (a.isDefault ? -1 : 0));
            if (!availableLanguages.some((l) => l.isDefault)) {
                availableLanguages[0].isDefault = true;
            }
            const defaultLanguage = ((_a = availableLanguages.find((s) => s.isDefault)) === null || _a === void 0 ? void 0 : _a.code) || 'en';
            if (props.languages) {
                spec.languages = availableLanguages;
            }
            if (this.config.multilingual) {
                this.context.languages = availableLanguages;
            }
            const languageToUse = props.language || defaultLanguage;
            // VAT types
            if (props.vatTypes) {
                spec.vatTypes = await (0, vat_types_1.getExistingVatTypes)(this.context);
                (0, utils_1.removeUnwantedFieldsFromThing)(spec.vatTypes, ['id', 'tenantId']);
            }
            // Subscription plans
            if (props.subscriptionPlans) {
                const subscriptionPlans = await (0, subscription_plans_1.getExistingSubscriptionPlans)(this.context);
                // @ts-expect-error ts complains that meteredVariables.unit cannot be a string. It must be
                spec.subscriptionPlans = subscriptionPlans.map((s) => {
                    var _a, _b;
                    return ({
                        identifier: s.identifier,
                        name: s.name || '',
                        meteredVariables: ((_a = s.meteredVariables) === null || _a === void 0 ? void 0 : _a.map((m) => ({
                            identifier: m.identifier,
                            name: m.name || '',
                            unit: m.unit,
                        }))) || [],
                        periods: ((_b = s.periods) === null || _b === void 0 ? void 0 : _b.map((p) => ({
                            name: p.name || '',
                            initial: (0, utils_1.removeUnwantedFieldsFromThing)(p.initial, ['id']),
                            recurring: (0, utils_1.removeUnwantedFieldsFromThing)(p.recurring, ['id']),
                        }))) || [],
                    });
                });
            }
            // Price variants
            const priceVariants = await (0, price_variants_1.getExistingPriceVariants)(this.context);
            if (props.priceVariants) {
                spec.priceVariants = priceVariants;
            }
            // Topic maps (in just 1 language right now)
            if (props.topicMaps) {
                spec.topicMaps = await (0, topics_1.getAllTopicsForSpec)(languageToUse, this.context);
                (0, utils_1.removeUnwantedFieldsFromThing)(spec.topicMaps, ['id']);
            }
            // Shapes
            if (props.shapes) {
                spec.shapes = await (0, shapes_1.getExistingShapesForSpec)(this.context);
            }
            const itemOptions = {
                basePath: '/',
                /**
                 * By setting external references for items that don't have
                 * it, we ensure that things itemRelations is far more
                 * reliable
                 */
                setExternalReference: true,
            };
            if (typeof props.items !== 'boolean') {
                const optionsOverride = props.items;
                Object.assign(itemOptions, optionsOverride);
            }
            // Grids
            if (props.grids) {
                spec.grids = await (0, get_all_grids_1.getAllGrids)(languageToUse, this.context, {
                    setItemExternalReference: itemOptions.setExternalReference,
                });
            }
            // Items
            if (props.items) {
                spec.items = await (0, get_all_catalogue_items_1.getAllCatalogueItems)(languageToUse, this.context, itemOptions);
                spec.items.forEach((i) => {
                    function handleLevel(a) {
                        if (a && typeof a === 'object') {
                            if ('subscriptionPlans' in a && 'sku' in a) {
                                (0, utils_1.removeUnwantedFieldsFromThing)(a.subscriptionPlans, ['id']);
                            }
                            else {
                                Object.values(a).forEach(handleLevel);
                            }
                        }
                        else if (Array.isArray(a)) {
                            a.forEach(handleLevel);
                        }
                    }
                    handleLevel(i);
                });
            }
            // Stock locations
            if (props.stockLocations) {
                spec.stockLocations = await (0, stock_locations_1.getExistingStockLocations)(this.context);
            }
            // Orders
            if (props.orders) {
                spec.orders = await (0, get_all_orders_1.getExistingOrders)({ context: this.context });
            }
            // Customers
            if (props.customers) {
                spec.customers = await (0, get_all_customers_1.getExistingCustomers)({ context: this.context });
            }
        }
        catch (e) {
            let error = e;
            if (e.stack) {
                error = `${e.stack}`;
            }
            const err = {
                error,
                willRetry: false,
            };
            this.emit(utils_1.EVENT_NAMES.ERROR, err);
        }
        return spec;
    }
    async start() {
        try {
            await this.ensureTenantExists();
            await this.getTenantBasics();
            if (this.PIMAPIManager && this.config.multilingual) {
                /**
                 * Due to a potential race condition when operating on
                 * multiple languages on the same time, we need to limit
                 * the amount of workers to 1 for now
                 */
                this.PIMAPIManager.useSingleWorker();
            }
            // Store the config in the context for easy access
            this.context.config = this.config;
            const start = new Date();
            if (this.config.shapeComponents === 'replace') {
                console.log("config.shapeComponents = 'replace' is not supported at the moment, falling back to the default option 'amend'");
            }
            await this.setLanguages();
            await this.setPriceVariants();
            await this.setStockLocations();
            await this.setSubscriptionPlans();
            await this.setVatTypes();
            await this.setShapes();
            await this.setTopics();
            await this.setGrids();
            await this.setItems();
            await this.setCustomers();
            await this.setOrders();
            // Set (update) grids again to update include the items
            await this.setGrids(true);
            const end = new Date();
            this.emit(utils_1.EVENT_NAMES.DONE, {
                start,
                end,
                duration: new duration_1.default(start, end).toString(1),
                spec: this.SPEC,
            });
        }
        catch (e) {
            let error = e;
            if (e.stack) {
                error = `${e.stack}`;
            }
            const err = {
                error,
                willRetry: false,
            };
            this.emit(utils_1.EVENT_NAMES.ERROR, err);
        }
    }
    areaUpdate(statusArea, areaUpdate) {
        if ('progress' in areaUpdate) {
            this.status = (0, immer_1.default)(this.status, (status) => {
                if (areaUpdate.progress) {
                    status[statusArea].progress = areaUpdate.progress;
                }
                if (areaUpdate.warning) {
                    status[statusArea].warnings.push(areaUpdate.warning);
                }
            });
            this.emit(utils_1.EVENT_NAMES.STATUS_UPDATE, this.status);
        }
        else if (areaUpdate.warning) {
            this.emit(utils_1.EVENT_NAMES.WARNING, areaUpdate.warning);
        }
        else if (areaUpdate.error) {
            const err = {
                error: JSON.stringify(areaUpdate.error, null, 1),
                areaError: areaUpdate.error,
                willRetry: false,
                type: 'error',
            };
            this.emit(utils_1.EVENT_NAMES.ERROR, err);
        }
    }
    async setLanguages() {
        var _a;
        const languages = await (0, languages_1.setLanguages)({
            spec: this.SPEC,
            context: this.context,
            onUpdate: (stepStatus) => {
                this.emit(utils_1.EVENT_NAMES.LANGUAGES_UPDATE, stepStatus);
                this.areaUpdate('languages', stepStatus);
            },
        });
        if (!languages) {
            throw new Error('Cannot get languages for the tenant');
        }
        this.context.languages = languages;
        const defaultLanguage = (_a = this.context.languages) === null || _a === void 0 ? void 0 : _a.find((l) => l.isDefault);
        if (!defaultLanguage) {
            throw new Error('Cannot determine default language for the tenant');
        }
        this.context.defaultLanguage = defaultLanguage.code;
        if (!this.config.multilingual) {
            this.context.languages = [defaultLanguage];
        }
        this.emit(utils_1.EVENT_NAMES.LANGUAGES_DONE);
    }
    async setShapes() {
        this.context.shapes = await (0, shapes_1.setShapes)({
            spec: this.SPEC,
            context: this.context,
            onUpdate: (areaUpdate) => {
                this.emit(utils_1.EVENT_NAMES.SHAPES_UPDATE, areaUpdate);
                this.areaUpdate('shapes', areaUpdate);
            },
        });
        this.emit(utils_1.EVENT_NAMES.SHAPES_DONE);
    }
    async setPriceVariants() {
        this.context.priceVariants = await (0, price_variants_1.setPriceVariants)({
            spec: this.SPEC,
            context: this.context,
            onUpdate: (areaUpdate) => {
                this.emit(utils_1.EVENT_NAMES.PRICE_VARIANTS_UPDATE, areaUpdate);
                this.areaUpdate('priceVariants', areaUpdate);
            },
        });
        this.emit(utils_1.EVENT_NAMES.PRICE_VARIANTS_DONE);
    }
    async setSubscriptionPlans() {
        this.context.subscriptionPlans = await (0, subscription_plans_1.setSubscriptionPlans)({
            spec: this.SPEC,
            context: this.context,
            onUpdate: (areaUpdate) => {
                this.emit(utils_1.EVENT_NAMES.SUBSCRIPTION_PLANS_UPDATE, areaUpdate);
                this.areaUpdate('subscriptionPlans', areaUpdate);
            },
        });
        this.emit(utils_1.EVENT_NAMES.SUBSCRIPTION_PLANS_DONE);
    }
    async setVatTypes() {
        this.context.vatTypes = await (0, vat_types_1.setVatTypes)({
            spec: this.SPEC,
            context: this.context,
            onUpdate: (areaUpdate) => {
                this.emit(utils_1.EVENT_NAMES.VAT_TYPES_UPDATE, areaUpdate);
                this.areaUpdate('vatTypes', areaUpdate);
            },
        });
        this.emit(utils_1.EVENT_NAMES.VAT_TYPES_DONE);
    }
    async setTopics() {
        await (0, topics_1.setTopics)({
            spec: this.SPEC,
            onUpdate: (areaUpdate) => {
                this.emit(utils_1.EVENT_NAMES.TOPICS_UPDATE, areaUpdate);
                this.areaUpdate('topicMaps', areaUpdate);
            },
            context: this.context,
        });
        this.emit(utils_1.EVENT_NAMES.TOPICS_DONE);
    }
    async setGrids(allowUpdate) {
        await (0, grids_1.setGrids)({
            spec: this.SPEC,
            onUpdate: (areaUpdate) => {
                this.emit(utils_1.EVENT_NAMES.GRIDS_UPDATE, areaUpdate);
                this.areaUpdate('grids', areaUpdate);
            },
            context: this.context,
            allowUpdate,
        });
        this.emit(utils_1.EVENT_NAMES.GRIDS_DONE);
    }
    async setItems() {
        await (0, setItems_1.setItems)({
            spec: this.SPEC,
            onUpdate: (areaUpdate) => {
                if (areaUpdate.message === 'media-upload-progress') {
                    this.areaUpdate('media', areaUpdate);
                }
                else {
                    this.emit(utils_1.EVENT_NAMES.ITEMS_UPDATE, areaUpdate);
                    this.areaUpdate('items', areaUpdate);
                }
            },
            context: this.context,
        });
        this.emit(utils_1.EVENT_NAMES.ITEMS_DONE);
    }
    async setStockLocations() {
        this.context.stockLocations = await (0, stock_locations_1.setStockLocations)({
            spec: this.SPEC,
            context: this.context,
            onUpdate: (areaUpdate) => {
                this.emit(utils_1.EVENT_NAMES.STOCK_LOCATIONS_UPDATE, areaUpdate);
                this.areaUpdate('stockLocations', areaUpdate);
            },
        });
        this.emit(utils_1.EVENT_NAMES.STOCK_LOCATIONS_DONE);
    }
    async setCustomers() {
        await (0, customers_1.setCustomers)({
            spec: this.SPEC,
            context: this.context,
            onUpdate: (areaUpdate) => {
                this.emit(utils_1.EVENT_NAMES.CUSTOMERS_UPDATE, areaUpdate);
                this.areaUpdate('customers', areaUpdate);
            },
        });
        this.emit(utils_1.EVENT_NAMES.CUSTOMERS_DONE);
    }
    async setOrders() {
        await (0, orders_1.setOrders)({
            spec: this.SPEC,
            context: this.context,
            onUpdate: (areaUpdate) => {
                this.emit(utils_1.EVENT_NAMES.ORDERS_UPDATE, areaUpdate);
                this.areaUpdate('orders', areaUpdate);
            },
        });
        this.emit(utils_1.EVENT_NAMES.ORDERS_DONE);
    }
    async kill() {
        var _a, _b, _c, _d;
        this.context.fileUploader.kill();
        (_a = this.PIMAPIManager) === null || _a === void 0 ? void 0 : _a.kill();
        (_b = this.catalogueAPIManager) === null || _b === void 0 ? void 0 : _b.kill();
        (_c = this.ordersAPIManager) === null || _c === void 0 ? void 0 : _c.kill();
        (_d = this.searchAPIManager) === null || _d === void 0 ? void 0 : _d.kill();
    }
}
exports.Bootstrapper = Bootstrapper;
